1) Store data in map where key is hash -> could shard internally based on first char of hash.
2) Once a node receives a new record, it should check with every other node that they have the record instead of each node
requesting new records. Can have a queue for each node which stores these update requests - if the node is down for too
long and the queue channel overflows, then write a list of update requests to a flat file?
3) If a node comes back up, don't start serving until it has processed all backlogged update requests from all other nodes.
4) Don't complete publish request until it has successfully been stored to more than one node. Prevents
data loss in the event of a node going down.

var data = map[string]Record{
    // hash is the hash of the original data point
    "a2145h3434dsgfsd786dsg5ssdf872361": Record{
        data: "this is an updated record!",
        timestamp: 1118736918,
        operations: []Operations{
                {Create, "this is the original record..."},
                {Update, "this is an updated record!"}
            }
        },

    }
}

type struct Record {
    data string
    timestamp uint8
    operations []Operation

}

type OperationType uint

const (
    Create OperationType = iota
    Update
    Delete
)

type struct Operation {
    type OperationType
    delta string
}


